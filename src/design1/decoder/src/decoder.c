#include <stdlib.h>
#include <stdio.h>
#include <stdint.h>
#include <string.h>
#include "mxc_device.h"
#include "status_led.h"
#include "board.h"
#include "mxc_delay.h"
#include "simple_flash.h"
#include "host_messaging.h"
#include "trng.h"
#include "tmr.h"

// secrets key file generated by gen_secrets
//#include "secrets.h"
#include "global.secrets"


#include "simple_uart.h"
#include "simple_crypto.h"

/**********************************************************
 ******************* PRIMITIVE TYPES **********************
 **********************************************************/

#define timestamp_t uint64_t
#define channel_id_t uint32_t
#define decoder_id_t uint32_t
#define pkt_len_t uint16_t
#define data_len_t uint32_t // just making it size of unsigned int so that packing the packet is easier > python has limited options

/**********************************************************
 *********************** CONSTANTS ************************
 **********************************************************/

#define MAX_CHANNEL_COUNT 8
#define EMERGENCY_CHANNEL 0
#define FRAME_SIZE 64
#define DEFAULT_CHANNEL_TIMESTAMP 0xFFFFFFFFFFFFFFFF
// This is a canary value so we can confirm whether this decoder has booted before
#define FLASH_FIRST_BOOT 0xDEADBEEF

/**********************************************************
 ********************* STATE MACROS ***********************
 **********************************************************/

// Calculate the flash address where we will store channel info as the 2nd to last page available
#define FLASH_STATUS_ADDR ((MXC_FLASH_MEM_BASE + MXC_FLASH_MEM_SIZE) - (2 * MXC_FLASH_PAGE_SIZE))

/**********************************************************
 *********** COMMUNICATION PACKET DEFINITIONS *************
 **********************************************************/

#pragma pack(push, 1) // Tells the compiler not to pad the struct members
// for more information on what struct padding does, see:
// https://www.gnu.org/software/c-intro-and-ref/manual/html_node/Structure-Layout.html
typedef struct {
    channel_id_t channel;
    timestamp_t timestamp;
    data_len_t size;
    uint8_t data[FRAME_SIZE];
} frame_packet_t;

typedef struct {
    decoder_id_t decoder_id;
    timestamp_t start_timestamp;
    timestamp_t end_timestamp;
    channel_id_t channel;
} subscription_update_packet_t;

typedef struct {
    channel_id_t channel;
    timestamp_t start;
    timestamp_t end;
} channel_info_t;

typedef struct {
    uint32_t n_channels;
    channel_info_t channel_info[MAX_CHANNEL_COUNT];
} list_response_t;

#pragma pack(pop) // Tells the compiler to resume padding struct members

/**********************************************************
 ******************** TYPE DEFINITIONS ********************
 **********************************************************/

typedef struct {
    bool active;
    channel_id_t id;
    timestamp_t start_timestamp;
    timestamp_t end_timestamp;
} channel_status_t;

typedef struct {
    uint32_t first_boot; // if set to FLASH_FIRST_BOOT, device has booted before.
    channel_status_t subscribed_channels[MAX_CHANNEL_COUNT];
} flash_entry_t;

/**********************************************************
 ************************ GLOBALS *************************
 **********************************************************/

// This is used to track decoder subscriptions
flash_entry_t decoder_status;

// global array to track the last processed timestamp per channel
static timestamp_t last_timestamps;

/**********************************************************
 ******************* UTILITY FUNCTIONS ********************
 **********************************************************/

/** @brief Checks whether the decoder is subscribed to a given channel
 *
 *  @param channel The channel number to be checked.
 *  @return 0 if emergency channel. returns 1 if subscribed channel. -1 if not subscribed.
*/
int is_subscribed(channel_id_t channel, timestamp_t timestamp) {
    // Check if this is an emergency broadcast message
    if (channel == EMERGENCY_CHANNEL) {
        return 0;
    }
    
    // Check if the decoder has has a subscription - > might be off by one error -> make sure it is not checking for channel 9
    for (int i = 0; i < MAX_CHANNEL_COUNT; i++) {
        // retrieves the start and end date of subscribtions for each channel
        // i.e. channel 1 start 1 end 100 -> time starts in boot and counts up
        uint64_t start = decoder_status.subscribed_channels[i].start_timestamp;
        uint64_t end = decoder_status.subscribed_channels[i].end_timestamp;
        // Ensure the channel is active and within the valid timestamp range
        if (decoder_status.subscribed_channels[i].id == channel && 
            decoder_status.subscribed_channels[i].active &&
            timestamp >= start && timestamp <= end) {

            // Monotonic timestamp enforcement (only in RAM)
            if (timestamp <= last_timestamps) {
                STATUS_LED_RED();
                return -1; // Reject frame due to non-monotonic timestamp
            }

            // Update last processed timestamp (stored in RAM only)
            last_timestamps = timestamp;
            return 1;
        }
    }
    return -1;
}


/**********************************************************
 ********************* CORE FUNCTIONS *********************
 **********************************************************/

/** @brief Lists out the actively subscribed channels over UART.
 *
 *  @return 0 if successful.
*/
int list_channels() {

    // Buffer to hold the response packet
    list_response_t resp;

    // Length of the response packet
    pkt_len_t len;

    resp.n_channels = 0;

    // Iterate through the subscribed channels and add them to the response packet
    for (uint32_t i = 0; i < MAX_CHANNEL_COUNT; i++) {
        if (decoder_status.subscribed_channels[i].active) {
            resp.channel_info[resp.n_channels].channel =  decoder_status.subscribed_channels[i].id;
            resp.channel_info[resp.n_channels].start = decoder_status.subscribed_channels[i].start_timestamp;
            resp.channel_info[resp.n_channels].end = decoder_status.subscribed_channels[i].end_timestamp;
            resp.n_channels++;
        }
    }

    // Calculate the length of the response packet
    len = sizeof(resp.n_channels) + (sizeof(channel_info_t) * resp.n_channels);

    // Success message
    write_packet(LIST_MSG, &resp, len);
    return 0;
}


/** @brief Updates the channel subscription for a subset of channels.
 *
 *  @param pkt_len The length of the incoming packet
 *  @param update A pointer to an array of channel_update structs,
 *      which contains the channel number, start, and end timestamps
 *      for each channel being updated.
 *
 *  @note Take care to note that this system is little endian.
 *
 *  @return 0 upon success.  -1 if error.
*/
int update_subscription(pkt_len_t pkt_len, uint8_t *update) {
    uint8_t decrypted_update[sizeof(subscription_update_packet_t)];  


    if(decrypt_sym(update, pkt_len, (uint8_t*)secret_key, decrypted_update) != 0){
        print_error("Decryption Failed! Invalid subscription update.");
        return -1;
    }

    uint8_t trimmed_message[sizeof(subscription_update_packet_t)];
    memcpy(trimmed_message, decrypted_update, sizeof(subscription_update_packet_t));

    // Cast the trimmed message
    subscription_update_packet_t *safe_update = (subscription_update_packet_t *)trimmed_message;

    int i;

    // Check if the channel is the emergency channel
    if (safe_update->channel == EMERGENCY_CHANNEL) {
        STATUS_LED_RED();
        print_error("Failed to update subscription - cannot subscribe to emergency channel\n");
        return -1;
    }

    if(safe_update->start_timestamp > safe_update->end_timestamp){
        print_error("timestamp start must be less than timestamp end");
        return -1;
    }
    //TODO check decoder ID -> stored decoder id on board 
    //make sure timestamp ranges are valid
    if(safe_update->decoder_id != DECODER_ID){
        print_error("Incorrect Decoder ID");
    }
    // Find the first empty slot in the subscription array
    for (i = 0; i < MAX_CHANNEL_COUNT; i++) {
        if (decoder_status.subscribed_channels[i].id == safe_update->channel || !decoder_status.subscribed_channels[i].active) {

            // Update the subscription with new information
            decoder_status.subscribed_channels[i].active = true;
            decoder_status.subscribed_channels[i].id = safe_update->channel;
            decoder_status.subscribed_channels[i].start_timestamp = safe_update->start_timestamp;
            decoder_status.subscribed_channels[i].end_timestamp = safe_update->end_timestamp;
            break;
        }
    }

    // Checks if the decoder has reached the maximum number of subscriptions
    if (i == MAX_CHANNEL_COUNT) {
        STATUS_LED_RED();
        print_error("Failed to update subscription - max subscriptions installed\n");
        return -1;
    }

    // Write the updated subscription data to flash memory
    flash_simple_erase_page(FLASH_STATUS_ADDR);
    flash_simple_write(FLASH_STATUS_ADDR, &decoder_status, sizeof(flash_entry_t));

    // Success message with an empty body
    write_packet(SUBSCRIBE_MSG, NULL, 0);
    return 0;
}


/**
 * @brief Processes a packet containing frame data.
 *
 * @param pkt_len Length of the incoming packet.
 * @param new_frame A pointer to the incoming encrypted packet.
 *
 * @return 0 if successful, -1 if data is from unsubscribed channel.
 */
int decode(pkt_len_t pkt_len, uint8_t *new_frame) {
    char output_buf[128] = {0};
    uint8_t decrypted_frame[pkt_len];

    // check that the packet_len is not greater than the maximum packet size
    if(pkt_len > MAX_PACKET_SIZE){
        print_error("packet length exceeds max length");
        return -1;
    }
    
    // Add a short randomized delay
    uint32_t rand_delay = MXC_TRNG_RandomInt() % 1000; // Random delay up to 999 microseconds
    int delay_count = 0;
    while(delay_count != rand_delay){
        int waste = 0;
        waste += 100;
        waste-=10;
        delay_count++;
    }

    // Perform first round of decryption on entire packet
    if (decrypt_sym(new_frame, pkt_len, (uint8_t*)secret_key, decrypted_frame) != 0) {
        print_error("failed to decrypt");
        return -1; // decryption failed
    }

    // cast the raw data as a frame_packet type in order to easily read the data.
    frame_packet_t *decrypted_packet = (frame_packet_t *)decrypted_frame;

    /*
    * This will calulate the size of the data with padding included.
    * decrypted_packet->size used here is the size of the data without padding
    * Padding needed for decryption to be successful (16 byte block size)
    */
    int padded_data_size = 0;
    if(((int)decrypted_packet->size % 16) != 0){
        padded_data_size = (decrypted_packet->size + (16 - ((int)decrypted_packet->size % 16))); // rounds up to nearst multiple of 16
    }
    else{
        padded_data_size = decrypted_packet->size;
    }

    uint8_t decrypted_message[padded_data_size];  // decrypted data with padding
    uint8_t trimmed_encrypted_data[padded_data_size];  // encrypted data with padding 

    // trims encrypted message with padding
    memcpy(trimmed_encrypted_data, decrypted_packet->data, padded_data_size); 
    uint8_t trimmed_message[decrypted_packet->size];  // decrypted message without padding

    /*
    if_subscribed()->
    -1 -> received unsubscribed channel data
    0 -> channel 0
    1 -> use that key (channel % 10007)
    */
    int subscribe_ret = is_subscribed(decrypted_packet->channel, decrypted_packet->timestamp);
    // Subscribed Channel
    if (subscribe_ret == 1) {
        uint8_t *second_key = (uint8_t*)channel_keys[((decrypted_packet->channel) % 10007)];
        if (decrypt_sym(trimmed_encrypted_data, padded_data_size, second_key, decrypted_message) != 0) {
            print_error("Failed to decrypt frame");
            return -1; // decryption failed
        }
        
        // trims off extra padding
        memcpy(trimmed_message, decrypted_message, decrypted_packet->size);
        write_packet(DECODE_MSG, trimmed_message, (uint16_t)decrypted_packet->size);
        return 0;
    }
    // Channel 0
    else if(subscribe_ret == 0){
        if (decrypt_sym(trimmed_encrypted_data, padded_data_size, (uint8_t*)secret_key, decrypted_message) != 0) {
            print_error("Failed to decrypt frame");
            return -1;
        }
        
        // this will trim off the padding from the data
        memcpy(trimmed_message, decrypted_message, decrypted_packet->size);
        // expects uint16_t casting 32 as 16 here - max val will be 15 so this works fine
        write_packet(DECODE_MSG, trimmed_message, (uint16_t)decrypted_packet->size);
        return 0;
    }
    // unsubscribed channel data
    else {
        STATUS_LED_RED();
        sprintf(
            output_buf,
            "Receiving unsubscribed channel data.  %u\n", decrypted_packet->channel);
        print_error(output_buf);
        return -1;
    }
}




/** @brief Initializes peripherals for system boot.
*/
void init() {
    int ret;

    // Initialize the flash peripheral to enable access to persistent memory
    flash_simple_init();


    // Read starting flash values into our flash status struct
    flash_simple_read(FLASH_STATUS_ADDR, &decoder_status, sizeof(flash_entry_t));
    


    if (decoder_status.first_boot != FLASH_FIRST_BOOT) {
        /* If this is the first boot of this decoder, mark all channels as unsubscribed.
        *  This data will be persistent across reboots of the decoder. Whenever the decoder
        *  processes a subscription update, this data will be updated.
        */
        decoder_status.first_boot = FLASH_FIRST_BOOT;

        channel_status_t subscription[MAX_CHANNEL_COUNT];

        for (int i = 0; i < MAX_CHANNEL_COUNT; i++){
            subscription[i].start_timestamp = DEFAULT_CHANNEL_TIMESTAMP;
            subscription[i].end_timestamp = DEFAULT_CHANNEL_TIMESTAMP;
            subscription[i].active = false;
        }

        // Write the starting channel subscriptions into flash.
        memcpy(decoder_status.subscribed_channels, subscription, MAX_CHANNEL_COUNT*sizeof(channel_status_t));

        flash_simple_erase_page(FLASH_STATUS_ADDR);
        flash_simple_write(FLASH_STATUS_ADDR, &decoder_status, sizeof(flash_entry_t));
    }

    // Initialize the uart peripheral to enable serial I/O
    ret = uart_init();
    if (ret < 0) {
        STATUS_LED_ERROR();
        // if uart fails to initialize, do not continue to execute
        while (1);
    }
    // sets last timestamp back to zero when power cycles
    last_timestamps = 0;
    /* Peripherial Initilization Here */

    // initilizes true random number generator
    if(MXC_TRNG_Init() != 0){
        print_error("TRNG initilization failed!");
    }


}

/**********************************************************
 *********************** MAIN LOOP ************************
 **********************************************************/

 #include <stdio.h>
 #include <stdint.h>
 
 int main(void) {
     char output_buf[128] = {0};
     uint8_t uart_buf[100];
     msg_type_t cmd;
     int result;
     uint16_t pkt_len;
 
     // Initialize the device
     init();

 
     // Process commands forever
     while (1) {
 
         STATUS_LED_GREEN();
 
        
         result = read_packet(&cmd, uart_buf, &pkt_len);
 
         if (result < 0) {
             STATUS_LED_ERROR();
             print_error("Failed to receive cmd from host");
             continue;
         }
 
         // Handle the requested command
         switch (cmd) {
         case LIST_MSG:
             STATUS_LED_CYAN();
             print_debug("Executing: LIST_MSG");
             list_channels();
             break;
 
         case DECODE_MSG:
             STATUS_LED_PURPLE();
             print_debug("Executing: DECODE_MSG");
             decode(pkt_len, uart_buf);
             break;
 
         case SUBSCRIBE_MSG:
             STATUS_LED_YELLOW();
             print_debug("Executing: SUBSCRIBE_MSG");
             update_subscription(pkt_len, uart_buf);
             break;
 
         default:
             STATUS_LED_ERROR();
             sprintf(output_buf, "Invalid Command: %c", cmd);
             print_error(output_buf);
             break;
         }
     }
 }
 